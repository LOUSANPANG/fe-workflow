---
title: 'JS & CSS代码优化'
description: 'JS & CSS代码优化'
---


# JS & CSS 代码优化




## JavaScript 代码方面


#### 使用文档碎片
  - 待添加元素 -> 文档碎片 -> 插入需要位置（减少 DOM 操作提高性能）。


#### 垃圾收集、内存管理
  - 堆内存无用数据值为 null。
  - 栈内存占用取消。
  - 避免内存泄漏（全局变量、闭包、DOM 元素的引用、定时器）。


#### Web Worker
  - 有繁重计算的代码抽离到 Web Worker。
  - 预先加载和存储一些数据。
  - 使用 Comlink 来简化与 Web Worker 之间的通信。


#### WebAssembly
  - 将繁重的计算任务抽离到 WebAssembly 执行。


#### 虚拟列表


#### 代码覆盖率识别并删除未使用的 CSS / JS，并进行压缩
  - Chrome Coverage 查看覆盖率结果，使用 import() 延迟加载。
  - purgecss、UnCSS、Helium 检测 CSS 删除未使用的样式。


#### 脚步加载方式、预热连接
  - *使用 defer、async 的加载方式。
  - *使用 dns-prefetch 提示浏览器该资源需要在用户点击链接之前进行 DNS 查询和协议握手。
  - *使用 preconnect 提前建立连接。
  - 使用 prefetch 提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。
  - 使用 preload 告诉浏览器下载资源，因为在当前导航期间稍后将需要该资源。


#### IntersectionObserver 延迟加载脚本 API
  - 




## CSS 代码方面


#### HTML 节点尽量少，避免深层次嵌套结构


#### 内联首屏关键 CSS
  - 内联在页面的 <head> 标签中，从而减少往返请求传输。
  - 由于在慢启动阶段 TCP 交换的包的大小有限，所以关键 CSS 的大小应该不超过14KB。
  - 超出这个限制范围，浏览器将需要额外的传输往返用于获取更多样式。


#### CSS 不同情况下的引用情况
  - 媒体查询条件把 CSS 文件进行拆分可能对我们的页面性能有一定提升（不同 media 适配，引入不同的 CSS 文件）。
  - 避免在 CSS 文件中使用 @import，会影响浏览器的并行下载。
  - 使用 scss、less 他们会将 @import 的文件直接包含在 CSS 中，并不会产生额外的 HTTP 请求。


#### 有选择地使用选择器
  - CSS 选择器的匹配是从右向左进行的。
  - 嵌套的层级更多，匹配所要花费的时间代价自然更高。
  - 通配符和属性选择器效率最低。


#### 减少回流和重绘
  - 始终在图像上设置宽度和高度属性，浏览器保留空间，后续图片资源加载完成后不需要回流。
  - 避免多次修改 DOM 属性，批量修改 DOM。
  - 脱离文档流：对于一些类似动画之类的频繁变更的 DOM.可以使用绝对定位将其脱离文档流，避免父元素频繁回流。
  - 渲染层提升为合成层
    - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快得多。
    - 当需要重绘时，只需要重绘本身，不会影响到其他的层。
    - 元素提升为合成层后，transform 和 opacity 才不会触发重绘，如果不是合成层，则其依然会触发重绘。
    ```css
      <!-- left、top 改为 transform -->
      @keyframes heartbeat{
        0%{top:30px;left:30px;}
        100%{top:230px;left:30px;}
       }
       @keyframes heartbeat{
          0%{transform: translate(30px,30px);}
          100%{transform: translate(230px,30px);}
       }

       <!-- transform 属性会启用硬件加速 -->
       .box { box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);}
       .box { transform: translateZ(0);  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);}
    ```


#### 提升渲染性能的CSS属性
  - content-visibility 控制一个元素是否渲染其内容，并且允许浏览器跳过这些元素的布局与渲染。
  - will-change 通知浏览器哪些元素和属性将会改变。
  - contain-intrinsic-size 指定的元素自然大小，确保我们未渲染子元素的 div 仍然占据空间。
  ```css
    .u-box {
      opacity: 1;
      transition: opacity 0.3s ease;
      will-change: opacity; /* 告知浏览器我们将会修改透明度 */
    }
  ```
 
 